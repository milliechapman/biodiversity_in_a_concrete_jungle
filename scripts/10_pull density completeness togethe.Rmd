---
title: "pull density completeness together"
author: "Dexter H. Locke, PhD"
date: "`r format(Sys.time())`"
output: html_document
editor_options: 
  chunk_output_type: console
---

PNAS, Ecology Letters.

Millie, to redo NDVI per HOLC polygons.

do boxplots with significance per taxon.
  or via nesting.
  
  dichotomize NWI water?
  

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

<!-- To retrieve a single file from an old commit to your working copy, simply use: -->

<!-- $ git checkout [revision_hash] [file_name] -->

<!-- You can use the HEAD pointer as the [revision_hash] if you want to: -->

<!--     HEAD - Points to the Last Commit on the current repository; -->

<!--     HEAD^ - Last Commit - 1; -->

<!--     HEAD^^ - Last Commit - 2; -->

<!--     HEAD~10 - 10 commits behind of HEAD; -->

<!--     Git checkout HEAD~1 filename -->


    
# 0 set up: load libraries, custom functions, set defaults
```{r}

# load libraries
# packages we'll be using
packs <- c(
    'tidyverse'  # a must have
  , 'tidylog'    # prints out what was done in dplyr and tidr
  # , 'gbifdb' # GBIF
  # , 'fst' # a faster table, makes outputs files much smaller, too.
  # , 'terra'
  # , 'KnowBR'    # creates biodiversity estimates like completeness.
  # , 'tidycensus'      # Census access
  , 'sf'        # spatial support
  , 'mapview'   # webmaps
  , 'janitor'   # cleans things up, also pipe-friendly cross-tabulations
  , 'tictoc'    # times things
  , 'beepr'     # makes noises
  , 'ggpubr'    # boxplots with significance testing.
)


# check for all of the libraries, install if you don't have them
if (length(setdiff(packs, rownames(installed.packages()))) > 0) {
  install.packages(setdiff(packs, rownames(installed.packages())))  
}

# load them
vapply(packs, library, character.only = TRUE, logical(1), logical.return = TRUE, quietly = TRUE)



# custom function for "Not In"
`%nin%` <- Negate(`%in%`)


# redlining colors
holc_pal <- c('#92BC6B' # green
              , '#92C7C9' # blue
              , '#E7DC6B' # yellow
              , '#E47D67' # red
              #, '#A9A9A9'
              ) # dark gray)

holc_pal_f<- c('#92BC6B' # green
              , '#92C7C9' # blue
              , '#E7DC6B' # yellow
              , '#E47D67' # red
              , '#A9A9A9'
              , '#000000')

# fixes mapview
mapviewOptions(fgb = FALSE)
```


# 1 read and combine data
```{r}
# setwd('_students/Diego/biodiversity_in_a_concrete_jungle/working_data/')
getwd()


(holc <- st_read('working_data/holc_polys_saved/holc_plys_2022-12-08 20-13-17.gpkg', as_tibble = TRUE) |> 
    filter(st_is(geom, 'POLYGON')) |> 
    select(id, holc_grade, area_holc_km2) |> 
    st_drop_geometry())

holc |> dim()
# list.files('_students/Diego/biodiversity_in_a_concrete_jungle/working_data/')

list.files()

# HOLC completeness and sampling density
holc_comp <-
  tibble(  filename = list.files('working_data/completeness', full.names = TRUE, recursive = TRUE, pattern = 'Estimators.CSV')
         , file_contents = map(filename, ~read_csv(., col_types = cols()))) |> 
  mutate(taxon = str_remove(filename, 'working_data/completeness/') |> 
           str_remove('/Estimators.CSV') |> 
           str_remove('_only') |> 
           str_remove('_graded')) |> 
  select(taxon, file_contents) |> 
  separate(taxon, into = c('taxon', 'level')) |> 
  mutate(level = ifelse(is.na(level), 'species', level)) |> 
  unnest(file_contents) |> 
  right_join(holc, by = c('Area' = 'id')) |> 
  # NA to zero on completeness
  mutate(density = Records / area_holc_km2) |>  
  left_join(read_csv('working_data/MSA/holc_msa_keys_2022-12-08 15-35-19.csv', col_types = 'cc') # makes type = character
            , by = c('Area' = 'id')
  ) |> 
  left_join(read_csv('working_data/MSA_UA_lookup.csv') |> 
              mutate(msa_GEOID = as.character(msa_GEOID)) |> 
              select(msa_GEOID, ua_GEOID)
            , by = 'msa_GEOID') |> 
  select(id = Area, density, completeness = Completeness, expected_richness = Richness, holc_grade, taxon, level, ua_GEOID, msa_GEOID) # cosmetic reorder
# interaction(grade, family?)

# TODO figure out why so many nas - because Right join, should those be zeros?
holc_comp |> filter(is.na(taxon))
holc_comp |> glimpse()
holc_comp |> group_by(id) |> count()

# MSA completeness and sampling density
msa_comp <-
  tibble(  filename = list.files('working_data/completeness_MSA', full.names = TRUE, recursive = TRUE)
         , file_contents = map(filename, ~read_csv(., col_types = cols()))) |> 
  mutate(taxon = str_remove(filename, 'working_data/completeness_MSA/') |> 
           str_remove('/Estimators.CSV') |> 
           str_remove('_graded') |> 
           str_remove('_not')) |> 
  separate(taxon, into = c('taxon', 'msa_GEOID'), sep = '/') |> #tabyl(taxon)
  separate(taxon, into = c('taxon', 'level')) |> 
  mutate( level = ifelse(is.na(level), 'species', level)
         , msa_GEOID = str_remove(msa_GEOID, 'msa_')) |> #tabyl(level, taxon)
  unnest(file_contents) |> 
  right_join(
    st_read('working_data/MSA_donut/msa_ungraded.gpkg', as_tibble = TRUE) |> 
      st_drop_geometry()
    , by = 'msa_GEOID'
  ) |> 
  mutate(  density = Records / area_msa_km2
         , holc_grade = 'MSA') |>  
  left_join(read_csv('working_data/MSA_UA_lookup.csv') |> 
              mutate(msa_GEOID = as.character(msa_GEOID)) |> 
              select(msa_GEOID, ua_GEOID)
            , by = 'msa_GEOID') |> 
  select(density, completeness = Completeness, expected_richness = Richness, holc_grade, taxon, level, ua_GEOID, msa_GEOID) # cosmetic reorder

msa_comp
msa_comp |> glimpse()
msa_comp |> group_by(msa_GEOID) |> count()
msa_comp |> group_by(ua_GEOID) |> count()


# UA completeness and sampling density
ua_comp <-
  tibble(  filename = list.files('working_data/completeness_UA', full.names = TRUE, recursive = TRUE)
         , file_contents = map(filename, ~read_csv(., col_types = cols()))) |> 
  mutate(taxon = str_remove(filename, 'working_data/completeness_UA/') |> 
           str_remove('/Estimators.CSV') |> 
           str_remove('_graded') |> 
           str_remove('_not')) |> 
  separate(taxon, into = c('taxon', 'ua_GEOID'), sep = '/') |> #tabyl(taxon)
  separate(taxon, into = c('taxon', 'level')) |> 
  mutate( level = ifelse(is.na(level), 'species', level)
         , ua_GEOID = str_remove(ua_GEOID, 'ua_')) |> #tabyl(level, taxon)
  unnest(file_contents) |>
  right_join(
    st_read('working_data/UA/UA_as_geopackage_2023-01-23 15-48-08.gpkg', as_tibble = TRUE) |> 
      st_drop_geometry() |> 
      select(ua_GEOID = GEOID, ua_area_km2)
    , by = 'ua_GEOID'
  ) |> 
  mutate(  density = Records / ua_area_km2
         , holc_grade = 'UA') |>  
  left_join(read_csv('working_data/MSA_UA_lookup.csv') |> mutate(msa_GEOID = as.character(msa_GEOID))
            , by = 'ua_GEOID') |>
  select(density, completeness = Completeness, expected_richness = Richness, holc_grade, taxon, level, ua_GEOID, msa_GEOID) # cosmetic reorder


ua_comp
ua_comp |> glimpse()
ua_comp |> group_by(msa_GEOID) |> count()
ua_comp |> group_by(ua_GEOID) |> count()


# mutate(holc_grade = factor(holc_grade, levels = c('A', 'B', 'C', 'D', 'UA', 'MSA')))
# TODO retain keys, save out
comp <- 
  bind_rows(holc_comp |> select(-id), msa_comp, ua_comp) |> 
  drop_na(taxon) |> 
  mutate(grade =
           factor(ifelse(level == 'species', holc_grade, paste0(holc_grade, ': family')),
                  levels = c(  "A",  "A: family"
                             , "B",  "B: family"
                             , "C",  "C: family"
                             , "D",  "D: family"
                             , "UA", "UA: family"
                             , "MSA","MSA: family"), ordered = TRUE)
         , `HOLC Grade` = factor(holc_grade
                                 , levels = c(LETTERS[1:4], 'UA', 'MSA'))
         ) |> 
  mutate(taxon = ifelse(level == 'species', taxon, paste0(taxon, ' (family)'))) |> #tabyl(taxon)
  droplevels()

# 2x checks
comp
comp |> View()
comp |> tabyl(holc_grade)
comp |> tabyl(holc_grade, taxon)
comp |> tabyl(holc_grade, taxon, level) |> bind_rows(.id = 'level') |> tibble() # HANDSOME TABLE!
```

TODO make viz and models script
TODO load data.

# 2 viz w boxplots
## A Density
### i combined no significance, stat_sla
```{r}

# all together with a facet.
comp |>
  # filter(taxon == 'aves') |>
  ggplot(aes(grade, density, fill = `HOLC Grade` # holc_grade
             # , color = level
             )) +
  ggdist::stat_halfeye(
    # adjust bandwidth
    adjust = 0.5,
    # move to the right
    justification = -0.2,
    # remove the slub interval
    .width = 0,
    point_colour = NA
    ) +
  geom_boxplot(
    width = 0.12,
    # removing outliers
    outlier.color = NA,
    # alpha = 0.5
    ) +
  #  ggdist::stat_dots(
  #   # ploting on left side
  #   side = "left",
  #   # adjusting position
  #   justification = 1.1,
  #   # adjust grouping (binning) of observations
  #   binwidth = 0.25
  # ) +
  # scale_y_sqrt(labels = scales::label_log(digits = 2)) +
  scale_y_log10(labels = scales::label_log(digits = 2)) +
  scale_fill_manual(values = holc_pal_f) +
  facet_wrap(~taxon, scales = 'free', nrow = 2) +
  theme_bw(16) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = .5), legend.position = c(.85, .25)) +
  # labs(title = 'sampling density') +
  labs(x = '', y = 'Sampling Density') +
  annotation_logticks(sides = 'l') +
  NULL

```


### ii combined WITH significance, no slabs
#### a 2 rows
```{r}

my_comparisons <- list(c("A", "B"), c("A", "C"), c("A", "D"), c("A", "UA"), c("A", "MSA"))
y1 <- expression(Sampling ~ Density: ~obs. ~ per ~ km^2)


comp |> 
  ggboxplot(x = 'HOLC Grade', y = 'density'
            , palette = holc_pal_f
            , fill = 'HOLC Grade'
             # , width = 0.12
            # removing outliers
            , outlier.color = NA
            , ggtheme = theme_pubr(base_size = 16)) +
  stat_compare_means(comparisons = my_comparisons
                     , method = 'wilcox.test'
                     , symnum.args = list(cutpoints = c(0, 0.0001, 0.001, 0.01, 0.05, Inf)
                                          , symbols = c("****", "***", "**", "*", "ns"))
                     ) +  # Add pairwise comparisons p-value
  # scale_y_sqrt(labels = scales::label_log(digits = 2)) +
  scale_y_log10(labels = scales::label_log(digits = 2)) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = .5), legend.position = c(.9, .25)) +
  labs(
    title = 'Sampling Density'
    , x = '', y = y1) +
  annotation_logticks(sides = 'l') +
  facet_wrap(~taxon, scales = 'free', nrow = 2) +
  NULL

# ggsave(  filename = paste0(getwd(), '/figures/sampling_density_', Sys.Date(), '.png')
#        # , width = 8.7, height = 10, units = 'cm'
#        , dpi = 450
#        , scale = 1.65)


```

#### b 3 rows
```{r}

my_comparisons <- list(c("A", "B"), c("A", "C"), c("A", "D"), c("A", "UA"), c("A", "MSA"))
y1 <- expression(Sampling ~ Density: ~obs. ~ per ~ km^2)


comp |> 
  ggboxplot(x = 'HOLC Grade', y = 'density'
            , palette = holc_pal_f
            , fill = 'HOLC Grade'
             # , width = 0.12
            # removing outliers
            , outlier.color = NA
            , ggtheme = theme_pubr(base_size = 16)) +
  stat_compare_means(comparisons = my_comparisons
                     , method = 'wilcox.test'
                     , symnum.args = list(cutpoints = c(0, 0.0001, 0.001, 0.01, 0.05, Inf)
                                          , symbols = c("****", "***", "**", "*", "ns"))
                     ) +  # Add pairwise comparisons p-value
  # scale_y_sqrt(labels = scales::label_log(digits = 2)) +
  scale_y_log10(labels = scales::label_log(digits = 2)) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = .5), legend.position = 'bottom') +
  labs(
    title = 'Sampling Density'
    , x = '', y = y1) +
  annotation_logticks(sides = 'l') +
  facet_wrap(~taxon, scales = 'free', nrow = 3) +
  NULL

# ggsave(  filename = paste0(getwd(), '/figures/sampling_density_3row_', Sys.Date(), '.png')
#        # , width = 8.7, height = 10, units = 'cm'
#        , dpi = 450
#        , scale = 1.65)


```


## B Completeness: combined WITH significance, no slabs
```{r}

my_comparisons <- list(c("A", "B"), c("A", "C"), c("A", "D"), c("A", "UA"), c("A", "MSA"))



comp |> 
  drop_na(completeness) |> # DROP NA
  ggboxplot(x = 'HOLC Grade', y = 'completeness'
            , palette = holc_pal_f
            , fill = 'HOLC Grade'
             # , width = 0.12
            # removing outliers
            , outlier.color = NA
            , ggtheme = theme_pubr(base_size = 16)) +
  stat_compare_means(comparisons = my_comparisons
                     , method = 'wilcox.test'
                     , symnum.args = list(cutpoints = c(0, 0.0001, 0.001, 0.01, 0.05, Inf)
                                          , symbols = c("****", "***", "**", "*", "ns"))
                     ) +  # Add pairwise comparisons p-value
  # scale_y_sqrt(labels = scales::label_log(digits = 2)) +
  # scale_y_log10(labels = scales::label_log(digits = 2)) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = .5), legend.position = c(.9, .25)) +
  labs(
    title = 'Estimated Completeness'
    , x = '', y = 'Completeness (%)') +
  # annotation_logticks(sides = 'l') + # used with log10 scale 
  facet_wrap(~taxon, scales = 'free', nrow = 2) +
  NULL

# ggsave(  filename = paste0(getwd(), '/figures/estimated_completeness_', Sys.Date(), '.png')
#        # , width = 8.7, height = 10, units = 'cm'
#        , dpi = 450
#        , scale = 1.65)


```


## C Expected richness: combined WITH significance, no slabs
```{r}

my_comparisons <- list(c("A", "B"), c("A", "C"), c("A", "D"), c("A", "UA"), c("A", "MSA"))



comp |> 
  drop_na(expected_richness) |> 
  ggboxplot(x = 'HOLC Grade', y = 'expected_richness'
            , palette = holc_pal_f
            , fill = 'HOLC Grade'
             # , width = 0.12
            # removing outliers
            , outlier.color = NA
            , ggtheme = theme_pubr(base_size = 16)) +
  stat_compare_means(comparisons = my_comparisons
                     , method = 'wilcox.test'
                     , symnum.args = list(cutpoints = c(0, 0.0001, 0.001, 0.01, 0.05, Inf)
                                          , symbols = c("****", "***", "**", "*", "ns"))
                     ) +  # Add pairwise comparisons p-value
  # scale_y_sqrt(labels = scales::label_log(digits = 2)) +
  scale_y_log10(labels = scales::label_log(digits = 2)) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = .5), legend.position = c(.9, .25)) +
  labs(
    title = 'Expected Richness'
    , x = '', y = 'Expected Species Richness') +
  annotation_logticks(sides = 'l') + # used with log10 scale
  facet_wrap(~taxon, scales = 'free', nrow = 2) +
  NULL

# ggsave(  filename = paste0(getwd(), '/figures/expected_richness_', Sys.Date(), '.png')
#        # , width = 8.7, height = 10, units = 'cm'
#        , dpi = 450
#        , scale = 1.65)


```


# models
```{r}

# TODO add HOLC as random SLOPE and see which is best: small sample size taxon.. eh

tic(); preds <-
  comp |>
  # replace_na(list(completeness = 0)) |>
  group_by(taxon, level) |>
  nest() |>
  # mutate(data        = map(data,  ~drop_na(.x))
  mutate(#  models_density = map(data, ~lm(density ~ holc_grade, .x))
  #, models_compl = map(data, ~lm(completeness ~ holc_grade, .x))
  models_density_msa = map(data, ~lme4::lmer(density ~ holc_grade + (1 | msa_GEOID), .x))
  , models_compl_msa   = map(data, ~lme4::lmer(completeness ~ holc_grade + (1 | msa_GEOID), .x))
  , models_rich_msa    = map(data, ~lme4::lmer(expected_richness ~ holc_grade + (1 | msa_GEOID), .x))
  , models_density_ua = map(data, ~lme4::lmer(density ~ holc_grade + (1 | ua_GEOID), .x))
  , models_compl_ua   = map(data, ~lme4::lmer(completeness ~ holc_grade + (1 | ua_GEOID), .x))
  , models_rich_ua    = map(data, ~lme4::lmer(expected_richness ~ holc_grade + (1 | ua_GEOID), .x))
  # random slope
  # , models_density_msa_rs = map(data, ~lme4::lmer(density ~ holc_grade + (holc_grade | msa_GEOID), .x))
  # , models_compl_msa_rs   = map(data, ~lme4::lmer(completeness ~ holc_grade + (holc_grade | msa_GEOID), .x))
  # , models_rich_msa_rs    = map(data, ~lme4::lmer(pred_richness ~ holc_grade + (holc_grade | msa_GEOID), .x))
  # , models_density_ua_rs = map(data, ~lme4::lmer(density ~ holc_grade + (holc_grade | ua_GEOID), .x))
  # , models_compl_ua_rs   = map(data, ~lme4::lmer(completeness ~ holc_grade + (holc_grade | ua_GEOID), .x))
  # , models_rich_ua_rs    = map(data, ~lme4::lmer(pred_richness ~ holc_grade + (holc_grade | ua_GEOID), .x))
  , ggpreds_density_msa = map(models_density_msa, ggeffects::ggpredict)
  , ggpreds_compl_msa   = map(models_compl_msa, ggeffects::ggpredict)
  , ggpreds_rich_msa    = map(models_rich_msa, ggeffects::ggpredict)
  , ggpreds_density_ua = map(models_density_ua, ggeffects::ggpredict)
  , ggpreds_compl_ua   = map(models_compl_ua, ggeffects::ggpredict)
  , ggpreds_rich_ua    = map(models_rich_ua, ggeffects::ggpredict)
  # random slope
  # , ggpreds_density_msa_rs = map(models_density_msa_rs, ggeffects::ggpredict)
  # , ggpreds_compl_msa_rs   = map(models_compl_msa_rs, ggeffects::ggpredict)
  # , ggpreds_rich_msa_rs    = map(models_rich_msa_rs, ggeffects::ggpredict)
  #
  # , ggpreds_density_ua_rs = map(models_density_ua_rs, ggeffects::ggpredict)
  # , ggpreds_compl_ua_rs   = map(models_compl_ua_rs, ggeffects::ggpredict)
  # , ggpreds_rich_ua_rs    = map(models_rich_ua_rs, ggeffects::ggpredict)
  ) |> 
  ungroup(); toc() # < 10 seconds

preds |> glimpse()

# which fit is better, UA or MSA
preds |>
  select(taxon, level, starts_with('models')) |>
  pivot_longer(cols = !c(taxon, level)) |>
  mutate(AIC = map(value, AIC)) |>
  unnest(AIC) |>
  arrange(taxon, level, desc(AIC))

# MSA sampling density
preds |>
  select(taxon, level, ggpreds_density_msa) |>
  unnest(ggpreds_density_msa) |>
  unnest(ggpreds_density_msa) |> 
  mutate(x = factor(x, levels = c('A', 'B', 'C', 'D', 'UA', 'MSA'))) |> # possibly not needed?
  ggplot(aes(x, predicted, color = level)) +
  geom_hline(yintercept = 0, color = 'black') +
  geom_point(aes(shape = level), position = position_dodge(width = 0.5), size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), position = position_dodge(width = 0.5), width = .3) +
  theme_bw(16) +
  # theme(legend.position = c(.75, .15)) +
  theme(legend.position = 'bottom') +
  scale_color_viridis_d(direction = -1, option = 'B', begin = 0, end = .5) +
  labs(title = 'sampling density with per-taxon models (9 in total)'
  , subtitle = 'birds are not representative!') +
  facet_wrap(~taxon, scales = 'free_y') +
  NULL

# UA sampling density
preds |>
  select(taxon, level, ggpreds_density_ua) |>
  unnest(ggpreds_density_ua) |>
  unnest(ggpreds_density_ua) |>
  mutate(x = factor(x, levels = c('A', 'B', 'C', 'D', 'UA', 'MSA'))) |>
  ggplot(aes(x, predicted, color = level)) +
  geom_hline(yintercept = 0, color = 'black') +
  geom_point(aes(shape = level), position = position_dodge(width = 0.5), size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), position = position_dodge(width = 0.5), width = .3) +
  theme_bw(16) +
  theme(legend.position = c(.75, .15)) +
  scale_color_viridis_d(direction = -1, option = 'B', begin = 0, end = .5) +
  labs(title = 'sampling density with per-taxon models (9 in total) UA'
  , subtitle = 'birds are not representative!') +
  facet_wrap(~taxon, scales = 'free_y') +
  NULL

# completeness
preds |>
  select(taxon, level, ggpreds_compl_msa) |>
  unnest(ggpreds_compl_msa) |>
  unnest(ggpreds_compl_msa) |>
  mutate(x = factor(x, levels = c('A', 'B', 'C', 'D', 'UA', 'MSA'))) |>
  ggplot(aes(x, predicted, color = level)) +
  geom_point(aes(shape = level), position = position_dodge(width = 0.5), size = 2) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), position = position_dodge(width = 0.5), width = .3) +
  theme_bw(16) +
  theme(legend.position = c(.75, .15)) +
  scale_color_viridis_d(direction = -1, option = 'B', begin = 0, end = .5) +
  labs(title = 'completeness with per-taxon models (9 in total) UA'
  , subtitle = 'birds are not representative!') +
  facet_wrap(~taxon, scales = 'free_y') +
  NULL

# expected richness
preds |>
  select(taxon, level, ggpreds_rich_msa) |>
  unnest(ggpreds_rich_msa) |>
  unnest(ggpreds_rich_msa) |>
  mutate(x = factor(x, levels = c('A', 'B', 'C', 'D', 'UA', 'MSA'))) |>
  ggplot(aes(x, predicted, color = level)) +
  geom_point(aes(shape = level), position = position_dodge(width = 0.5), size = 2) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), position = position_dodge(width = 0.5), width = .3) +
  theme_bw(16) +
  theme(legend.position = c(.75, .15)) +
  scale_color_viridis_d(direction = -1, option = 'B', begin = 0, end = .5) +
  labs(title = 'expected richness with per-taxon models (9 in total) UA'
  , subtitle = 'birds are not representative!') +
  facet_wrap(~taxon, scales = 'free_y') +
  NULL


```








