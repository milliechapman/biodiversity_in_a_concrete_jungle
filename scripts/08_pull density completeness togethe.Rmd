---
title: "pull density completeness together"
author: "Dexter H. Locke, PhD"
date: "`r format(Sys.time())`"
output: html_document
editor_options: 
  chunk_output_type: console
---

PNAS, Ecology Letters.

Millie, to redo NDVI per HOLC polygons.

do boxplots with significance per taxon.
  or via nesting.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

<!-- To retrieve a single file from an old commit to your working copy, simply use: -->

<!-- $ git checkout [revision_hash] [file_name] -->

<!-- You can use the HEAD pointer as the [revision_hash] if you want to: -->

<!--     HEAD - Points to the Last Commit on the current repository; -->

<!--     HEAD^ - Last Commit - 1; -->

<!--     HEAD^^ - Last Commit - 2; -->

<!--     HEAD~10 - 10 commits behind of HEAD; -->

<!--     Git checkout HEAD~1 filename -->


    
# 0 set up: load libraries, custom functions, set defaults
```{r}

# load libraries
# packages we'll be using
packs <- c(
    'tidyverse'  # a must have
  , 'tidylog'    # prints out what was done in dplyr and tidr
  # , 'gbifdb' # GBIF
  # , 'fst' # a faster table, makes outputs files much smaller, too.
  # , 'terra'
  # , 'KnowBR'    # creates biodiversity estimates like completeness.
  # , 'tidycensus'      # Census access
  , 'sf'        # spatial support
  , 'mapview'   # webmaps
  , 'janitor'   # cleans things up, also pipe-friendly cross-tabulations
  , 'tictoc'    # times things
  , 'beepr'     # makes noises
)


# check for all of the libraries, install if you don't have them
if (length(setdiff(packs, rownames(installed.packages()))) > 0) {
  install.packages(setdiff(packs, rownames(installed.packages())))  
}

# load them
vapply(packs, library, character.only = TRUE, logical(1), logical.return = TRUE, quietly = TRUE)



# custom function for "Not In"
`%nin%` <- Negate(`%in%`)


# redlining colors
holc_pal <- c('#92BC6B' # green
              , '#92C7C9' # blue
              , '#E7DC6B' # yellow
              , '#E47D67' # red
              #, '#A9A9A9'
              ) # dark gray)

holc_pal_f<- c('#92BC6B' # green
              , '#92C7C9' # blue
              , '#E7DC6B' # yellow
              , '#E47D67' # red
              , '#A9A9A9'
              , '#000000')

# fixes mapview
mapviewOptions(fgb = FALSE)
```




# NDVI
```{r}

# read through each of the geography-specific files, group_by. and create mean.



# 
# 
# # list.files('working_data/MSA')
# # msa   <- st_read('working_data/MSA/msa_as_geopackage_2022-12-08 15-40-07.gpkg')
# # msa_u <- st_read('working_data/MSA_donut/msa_ungraded.gpkg')
# 
# list.files('working_data/ndvi')
# list.files('working_data')
# 
# ndvi <- read_csv('working_data/mean_ndvi.csv')
# 
# # MSA: we tried to make ndvi character, then we tried make msa numeric.
# msa |> 
#   mutate(GEOID = as.numeric(msa_GEOID)) |> 
#   left_join(
#     ndvi |>
#       filter(area == 'msa') #|> 
#       # mutate(msa_GEOID = as.character(GEOID))
#       , by = c('GEOID')
#     ) |> 
#   filter(!is.na(mean_ndvi)) # none matched
# 
# 
# # M
# msa |> 
#   left_join(
#     ndvi |>
#       filter(area == 'msa') |> 
#       mutate(msa_GEOID = as.character(GEOID))
#       , by = c('msa_GEOID'))
# 
# 
# 
# # test_ndvi <- read_csv("working_data/ndvi/modis250_ndvi_msa_2018.csv")
# test_ndvi <- read_csv("working_data/ndvi/modis250_ndvi_")
# 
# msa |> 
#   mutate(msa_GEOID = as.double(msa_GEOID)) |> 
#   left_join(test_ndvi, by = c('msa_GEOID' = 'm_GEOID'))



```




# read in data

```{r}
# setwd('_students/Diego/biodiversity_in_a_concrete_jungle/working_data/')
getwd()


(holc <- st_read('working_data/holc_polys_saved/holc_plys_2022-12-08 20-13-17.gpkg', as_tibble = TRUE) |> 
    filter(st_is(geom, 'POLYGON')) |> 
    select(id, holc_grade, area_holc_km2) |> 
    st_drop_geometry())

holc |> dim()
# list.files('_students/Diego/biodiversity_in_a_concrete_jungle/working_data/')

list.files()

# HOLC completeness and sampling density
holc_comp <-
  tibble(  filename = list.files('working_data/completeness', full.names = TRUE, recursive = TRUE, pattern = 'Estimators.CSV')
         , file_contents = map(filename, ~read_csv(., col_types = cols()))) |> 
  mutate(taxon = str_remove(filename, 'working_data/completeness/') |> 
           str_remove('/Estimators.CSV') |> 
           str_remove('_only') |> 
           str_remove('_graded')) |> 
  select(taxon, file_contents) |> 
  separate(taxon, into = c('taxon', 'level')) |> 
  mutate(level = ifelse(is.na(level), 'species', level)) |> 
  unnest(file_contents) |> 
  right_join(holc, by = c('Area' = 'id')) |> 
  # NA to zero on completeness
  mutate(density = Records / area_holc_km2) |>  
  left_join(read_csv('working_data/MSA/holc_msa_keys_2022-12-08 15-35-19.csv', col_types = 'cc') # makes type = character
            , by = c('Area' = 'id')
  ) |> 
  left_join(read_csv('working_data/MSA_UA_lookup.csv') |> 
              mutate(msa_GEOID = as.character(msa_GEOID)) |> 
              select(msa_GEOID, ua_GEOID)
            , by = 'msa_GEOID') |> 
  select(id = Area, density, completeness = Completeness, pred_richness = Richness, holc_grade, taxon, level, ua_GEOID, msa_GEOID) # cosmetic reorder
# interaction(grade, family?)

# TODO figure out why so many nas - because Right join, should those be zeros?
holc_comp |> filter(is.na(taxon))
holc_comp |> glimpse()
holc_comp |> group_by(id) |> count()

# MSA completeness and sampling density
msa_comp <-
  tibble(  filename = list.files('working_data/completeness_MSA', full.names = TRUE, recursive = TRUE)
         , file_contents = map(filename, ~read_csv(., col_types = cols()))) |> 
  mutate(taxon = str_remove(filename, 'working_data/completeness_MSA/') |> 
           str_remove('/Estimators.CSV') |> 
           str_remove('_graded') |> 
           str_remove('_not')) |> 
  separate(taxon, into = c('taxon', 'msa_GEOID'), sep = '/') |> #tabyl(taxon)
  separate(taxon, into = c('taxon', 'level')) |> 
  mutate( level = ifelse(is.na(level), 'species', level)
         , msa_GEOID = str_remove(msa_GEOID, 'msa_')) |> #tabyl(level, taxon)
  unnest(file_contents) |> 
  right_join(
    st_read('working_data/MSA_donut/msa_ungraded.gpkg', as_tibble = TRUE) |> 
      st_drop_geometry()
    , by = 'msa_GEOID'
  ) |> 
  mutate(  density = Records / area_msa_km2
         , holc_grade = 'MSA') |>  
  left_join(read_csv('working_data/MSA_UA_lookup.csv') |> 
              mutate(msa_GEOID = as.character(msa_GEOID)) |> 
              select(msa_GEOID, ua_GEOID)
            , by = 'msa_GEOID') |> 
  select(density, completeness = Completeness, pred_richness = Richness, holc_grade, taxon, level, ua_GEOID, msa_GEOID) # cosmetic reorder

msa_comp
msa_comp |> glimpse()
msa_comp |> group_by(msa_GEOID) |> count()
msa_comp |> group_by(ua_GEOID) |> count()


# UA completeness and sampling density
ua_comp <-
  tibble(  filename = list.files('working_data/completeness_UA', full.names = TRUE, recursive = TRUE)
         , file_contents = map(filename, ~read_csv(., col_types = cols()))) |> 
  mutate(taxon = str_remove(filename, 'working_data/completeness_UA/') |> 
           str_remove('/Estimators.CSV') |> 
           str_remove('_graded') |> 
           str_remove('_not')) |> 
  separate(taxon, into = c('taxon', 'ua_GEOID'), sep = '/') |> #tabyl(taxon)
  separate(taxon, into = c('taxon', 'level')) |> 
  mutate( level = ifelse(is.na(level), 'species', level)
         , ua_GEOID = str_remove(ua_GEOID, 'ua_')) |> #tabyl(level, taxon)
  unnest(file_contents) |>
  right_join(
    st_read('working_data/UA/UA_as_geopackage_2023-01-23 15-48-08.gpkg', as_tibble = TRUE) |> 
      st_drop_geometry() |> 
      select(ua_GEOID = GEOID, ua_area_km2)
    , by = 'ua_GEOID'
  ) |> 
  mutate(  density = Records / ua_area_km2
         , holc_grade = 'UA') |>  
  left_join(read_csv('working_data/MSA_UA_lookup.csv') |> mutate(msa_GEOID = as.character(msa_GEOID))
            , by = 'ua_GEOID') |>
  select(density, completeness = Completeness, pred_richness = Richness, holc_grade, taxon, level, ua_GEOID, msa_GEOID) # cosmetic reorder


ua_comp
ua_comp |> glimpse()
ua_comp |> group_by(msa_GEOID) |> count()
ua_comp |> group_by(ua_GEOID) |> count()


# mutate(holc_grade = factor(holc_grade, levels = c('A', 'B', 'C', 'D', 'UA', 'MSA')))

comp <- 
  bind_rows(holc_comp |> select(-id), msa_comp, ua_comp) |> 
  drop_na(taxon) |> 
  mutate(grade = factor(ifelse(level == 'species', holc_grade, paste0(holc_grade, ': family')),
         levels = c(  "A",  "A: family"
                    , "B",  "B: family"
                    , "C",  "C: family"
                    , "D",  "D: family"
                    , "UA", "UA: family"
                    , "MSA","MSA: family"), ordered = TRUE))


comp
comp |> View()
comp |> tabyl(holc_grade)
comp |> tabyl(holc_grade, taxon)
comp |> tabyl(holc_grade, taxon, level) |> bind_rows(.id = 'level') |> tibble() # HANDSOME TABLE!



comp |>
  drop_na(taxon) |>
  mutate(grade = factor(ifelse(level == 'species', holc_grade, paste0(holc_grade, ': family')),
                        levels = c(  "A",  "A: family"
                                   , "B",  "B: family"
                                  , "C",  "C: family"
                                  , "D",  "D: family"
                                  , "UA", "UA: family"
                                  , "MSA","MSA: family"), ordered = TRUE)
                                  , `HOLC Grade` = factor(holc_grade
                                  , levels = c(LETTERS[1:4], 'UA', 'MSA'))
                                  ) |>
  # filter(taxon == 'aves') |>
  ggplot(aes(grade, density, fill = `HOLC Grade` # holc_grade
             # , color = level
             )) +
  ggdist::stat_halfeye(
    # adjust bandwidth
    adjust = 0.5,
    # move to the right
    justification = -0.2,
    # remove the slub interval
    .width = 0,
    point_colour = NA
    ) +
  geom_boxplot(
    width = 0.12,
    # removing outliers
    outlier.color = NA,
    # alpha = 0.5
    ) +
  #  ggdist::stat_dots(
  #   # ploting on left side
  #   side = "left",
  #   # adjusting position
  #   justification = 1.1,
  #   # adjust grouping (binning) of observations
  #   binwidth = 0.25
  # ) +
  # scale_y_sqrt(labels = scales::label_log(digits = 2)) +
    scale_y_log10(labels = scales::label_log(digits = 2)) +
  # scale_y_sqrt() +
  scale_fill_manual(values = holc_pal_f) +
  facet_wrap(~taxon, scales = 'free', nrow = 2) +
  theme_bw(16) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = .5), legend.position = c(.85, .25)) +
  # labs(title = 'sampling density') +
  labs(x = '', y = 'Sampling Density') +
  annotation_logticks(sides = 'l') +
  NULL

```

# models
```{r}

# TODO add HOLC as random SLOPE and see which is best: small sample size taxon.. eh
tic(); preds <-
comp |>
# replace_na(list(completeness = 0)) |>
group_by(taxon, level) |>
nest() |>
# mutate(data        = map(data,  ~drop_na(.x))
mutate(#  models_density = map(data, ~lm(density ~ holc_grade, .x))
#, models_compl = map(data, ~lm(completeness ~ holc_grade, .x))
models_density_msa = map(data, ~lme4::lmer(density ~ holc_grade + (1 | msa_GEOID), .x))
, models_compl_msa   = map(data, ~lme4::lmer(completeness ~ holc_grade + (1 | msa_GEOID), .x))
, models_rich_msa    = map(data, ~lme4::lmer(pred_richness ~ holc_grade + (1 | msa_GEOID), .x))
, models_density_ua = map(data, ~lme4::lmer(density ~ holc_grade + (1 | ua_GEOID), .x))
, models_compl_ua   = map(data, ~lme4::lmer(completeness ~ holc_grade + (1 | ua_GEOID), .x))
, models_rich_ua    = map(data, ~lme4::lmer(pred_richness ~ holc_grade + (1 | ua_GEOID), .x))
# random slope
# , models_density_msa_rs = map(data, ~lme4::lmer(density ~ holc_grade + (holc_grade | msa_GEOID), .x))
# , models_compl_msa_rs   = map(data, ~lme4::lmer(completeness ~ holc_grade + (holc_grade | msa_GEOID), .x))
# , models_rich_msa_rs    = map(data, ~lme4::lmer(pred_richness ~ holc_grade + (holc_grade | msa_GEOID), .x))
# , models_density_ua_rs = map(data, ~lme4::lmer(density ~ holc_grade + (holc_grade | ua_GEOID), .x))
# , models_compl_ua_rs   = map(data, ~lme4::lmer(completeness ~ holc_grade + (holc_grade | ua_GEOID), .x))
# , models_rich_ua_rs    = map(data, ~lme4::lmer(pred_richness ~ holc_grade + (holc_grade | ua_GEOID), .x))
, ggpreds_density_msa = map(models_density_msa, ggeffects::ggpredict)
, ggpreds_compl_msa   = map(models_compl_msa, ggeffects::ggpredict)
, ggpreds_rich_msa    = map(models_rich_msa, ggeffects::ggpredict)
, ggpreds_density_ua = map(models_density_ua, ggeffects::ggpredict)
, ggpreds_compl_ua   = map(models_compl_ua, ggeffects::ggpredict)
, ggpreds_rich_ua    = map(models_rich_ua, ggeffects::ggpredict)
# random slope
# , ggpreds_density_msa_rs = map(models_density_msa_rs, ggeffects::ggpredict)
# , ggpreds_compl_msa_rs   = map(models_compl_msa_rs, ggeffects::ggpredict)
# , ggpreds_rich_msa_rs    = map(models_rich_msa_rs, ggeffects::ggpredict)
#
# , ggpreds_density_ua_rs = map(models_density_ua_rs, ggeffects::ggpredict)
# , ggpreds_compl_ua_rs   = map(models_compl_ua_rs, ggeffects::ggpredict)
# , ggpreds_rich_ua_rs    = map(models_rich_ua_rs, ggeffects::ggpredict)
); toc() # < 10 seconds
preds |> glimpse()
# which fit is better, UA or MSA
preds |>
select(taxon, level, starts_with('models')) |>
pivot_longer(cols = !c(taxon, level)) |>
mutate(AIC = map(value, AIC)) |>
unnest(AIC) |>
arrange(taxon, level, desc(AIC))
preds |>
select(taxon, level, ggpreds_density_msa) |>
unnest(ggpreds_density_msa) |>
mutate(x = factor(x, levels = c('A', 'B', 'C', 'D', 'UA', 'MSA'))) |>
ggplot(aes(x, predicted, color = level)) +
geom_hline(yintercept = 0, color = 'black') +
geom_point(aes(shape = level), position = position_dodge(width = 0.5), size = 3) +
geom_errorbar(aes(ymin = conf.low, ymax = conf.high), position = position_dodge(width = 0.5), width = .3) +
theme_bw(16) +
theme(legend.position = c(.75, .15)) +
scale_color_viridis_d(direction = -1, option = 'B', begin = 0, end = .5) +
labs(title = 'sampling density with per-taxon models (9 in total)'
, subtitle = 'birds are not representative!') +
facet_wrap(~taxon, scales = 'free_y') +
NULL
preds |>
select(taxon, level, ggpreds_density_ua) |>
unnest(ggpreds_density_ua) |>
mutate(x = factor(x, levels = c('A', 'B', 'C', 'D', 'UA', 'MSA'))) |>
ggplot(aes(x, predicted, color = level)) +
geom_hline(yintercept = 0, color = 'black') +
geom_point(aes(shape = level), position = position_dodge(width = 0.5), size = 3) +
geom_errorbar(aes(ymin = conf.low, ymax = conf.high), position = position_dodge(width = 0.5), width = .3) +
theme_bw(16) +
theme(legend.position = c(.75, .15)) +
scale_color_viridis_d(direction = -1, option = 'B', begin = 0, end = .5) +
labs(title = 'sampling density with per-taxon models (9 in total) UA'
, subtitle = 'birds are not representative!') +
facet_wrap(~taxon, scales = 'free_y') +
NULL
# completeness
preds |>
select(taxon, level, ggpreds_compl_msa) |>
unnest(ggpreds_compl_msa) |>
mutate(x = factor(x, levels = c('A', 'B', 'C', 'D', 'UA', 'MSA'))) |>
ggplot(aes(x, predicted, color = level)) +
geom_point(aes(shape = level), position = position_dodge(width = 0.5), size = 2) +
geom_errorbar(aes(ymin = conf.low, ymax = conf.high), position = position_dodge(width = 0.5), width = .3) +
theme_bw(16) +
theme(legend.position = c(.75, .15)) +
scale_color_viridis_d(direction = -1, option = 'B', begin = 0, end = .5) +



```








